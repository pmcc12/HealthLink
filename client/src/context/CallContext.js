import React, { createContext, useContext, useEffect, useRef, useState } from "react";
import {io} from 'socket.io-client'
import Peer from 'simple-peer'
import { useUser } from "./UserContext";

const CallContext = createContext();


//context will be available to all children who can have rights of access to calling data

export const CallContextProvider = ({children}) => {
    
    const {userId,isDoctor,appointmentId} = useUser();

    // const socket = io('http://localhost:8080/');
    const [socket] = useState(io('http://localhost:8080/'))
    const [stream, setStream] = useState(null);
    const [me, setMe] = useState('');
    const [call, setCall] = useState({});
    const [callAccepted, setCallAccepted] = useState(false);
    const [callEnded, setCallEnded] = useState(false);
    const [name, setName] = useState('');
    
    const myVideo = useRef({}); //is a html video element with my video
    const userVideo = useRef({}); //is a html video element with my video
    const connectionRef = useRef({}); //need a reference outside this function for when i want to destroy the call
    

    //context is created so that children components at any point can access to state and inner methods
    
    useEffect(() => {
        
        navigator.mediaDevices.getUserMedia({
            video: true,
            audio:true
        })
        .then((incomingStream) => {
            setStream(incomingStream);
            myVideo.current.srcObject = incomingStream;
        });

        console.log('it starts!');
        
        //saves my socket.id (created by the signalling server). listening since beginning
        
        socket.on('ownuser', (id) => {
            console.log('got it!');    
            setMe(id)
        });

        //this particular event is received by the user that is receiving the call (callee) (with the data from the user trying to establish connection forwarded by the signalling server)
        //event 'call' originated from the signalling server
        socket.on('call',({senderUser,senderName,signal}) => {
            console.log('senderId: ',senderUser,' and senderName: ',senderName);
            console.log('signal: ',signal);
            setCall({
                //this event will be sensed by the receiver
                isReceivedCall: true,
                //caller socket.id 
                from: senderUser,
                //caller name 
                name: senderName,
                //signal generated by the new Peer() 
                signal
            });
        })
    }, []);

    useEffect(() => {
        if(isDoctor){
            //me will be equal to '' by default on the beginning, therefore, and to avoid unnecessary queries to the DB, will only perform these time consuming operations, only when strictly necessary (i.e. when we have a actual socket peerid set)
            if(me !== ''){
                updateDoctorPeerId();
                //emit to the other client that we're ready forthe call
            }
        } else {
            if(me !== ''){
                updatePatientPeerId();
                //emit to other client that we're ready for the call
            } 
        }
        updateAppointmentPeer();

    }, [me])

    const updateDoctorPeerId = () => {
        console.log('going to fetch a doctor with userid: '+userId+' and a peerid: '+me);
        return fetch(`${process.env.REACT_APP_HOST}/doctor/${userId}`, {
            method: "PUT",
            credentials: 'include',
            mode: 'cors',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                peerid: me
            })
        })
    }

    const updatePatientPeerId = () => {
        console.log('going to fetch a patient with userid: '+userId+' and a peerid: '+me);
        return fetch(`${process.env.REACT_APP_HOST}/patient/${userId}`, {
            method: "PUT",
            credentials: 'include',
            mode: 'cors',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                peerid: me
            })
        })
    }

    const deleteAppointment = (appointmentId) => {
        console.log('going to delete an appointment with id: '+appointmentId);
        return fetch(`${process.env.REACT_APP_HOST}/appointment/${appointmentId}`, {
            method: "DELETE",
            credentials: 'include',
            mode: 'cors',
            headers: {
                'content-type': 'application/json'
            }
        })
    }

    const getAppointment = (appointmentId) => {
        console.log('going to GET an appointment with id: '+appointmentId);
        return fetch(`${process.env.REACT_APP_HOST}/appointment/${appointmentId}`, {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                'content-type': 'application/json'
            }
        })
        .then(res => res.json());
    }

    const updateAppointmentPeer = () => {
        console.log('update peer')
        if(isDoctor){
            console.log('i am a doctor')
            return fetch(`${process.env.REACT_APP_HOST}/appointment/${appointmentId}`, {
                method: "PUT",
                credentials: 'include',
                mode: 'cors',
                headers: {
                    'content-type': 'application/json'
                },
                body: JSON.stringify({
                    peerIdDoctor: me,
                })
            })
        } else {
            console.log('i am a patient');
            console.log('appointment id: ',appointmentId);
            return fetch(`${process.env.REACT_APP_HOST}/appointment/${appointmentId}`, {
                method: "PUT",
                credentials: 'include',
                mode: 'cors',
                headers: {
                    'content-type': 'application/json'
                },
                body: JSON.stringify({
                    peerIdPatient: me
                })
            })
        }
    }

    //when we want try a call, we need to have the callee id (id)
    const callUser = (id) => {
        //when Peer() is instantiated (regardless the fact we are or not the initiator, and event 'signal' (which basically is encapsulating webrtc offers/answers and ICE candidates.. rough process difficult to bear which simple-peer helps us to abstract from))
        const callerPeer = new Peer({
            initiator: true,
            trickle: false,
            stream: stream //my stream i need to pass to the callee
        });

        //will capture the signal originated above and emit it to the other user through the signalling server
        callerPeer.on('signal', (data) => {
            //here is where all starts
            socket.emit('call', {destinationUser: id, signallingData: data, from:me,name: name});
        });

        //when communication is established and a stream from the callee is received, we need to show it on the correct video tag
        callerPeer.on('stream', (streamFromCallee) => {
            userVideo.current.srcObject = streamFromCallee;
        });

        //as a caller, we expect to receive an answer, when positive answer comes, then we will try to establish a connection
        socket.on('callaccepted',(signal) => {
            console.log('acceptance received');
            console.log('at caller signal: ',signal);
            setCallAccepted(true); //for conditional rendering.. if accepted than we will show callee window
            callerPeer.signal(signal); //final handshaking is done here. Trying p2p connection
        });
        //need a reference outside this function for when i want to destroy the call
        connectionRef.current = callerPeer;
    };

    const answerCall = () => {

        setCallAccepted(true);

        const calleePeer = new Peer({
            initiator: false,
            trickle: false,
            stream: stream //my stream i need to pass to the callee
        });

        console.log('answer call');
        console.log('callerId: ',call.from);
        console.log('signal: ', call.signal);

        calleePeer.on('signal', (data) => {
            //here is where the answer starts (signalling process.. only after caller receive the signalling data from callee, will attempt to establish p2p connection)
            console.log('answer. callerId:',call.from);
            console.log('signal data: ',data);
            socket.emit('answer', {signaldata: data, callerId: call.from});
        });

        calleePeer.on('stream', (streamFromCaller) => {
            //the other user video, from the point of view of the callee (who is answering the call, is the userVideo and not myVideo)
            userVideo.current.srcObject = streamFromCaller;
        });

        //callee attempts to establish p2p connection with caller.. only will be achieved after caller received the signalling data sent on line 92 via websockets
        calleePeer.signal(call.signal);
         //need a reference outside this function for when i want to destroy the call
        connectionRef.current = calleePeer;
    }

    const endCall = () => {

        console.log('call ended!');
        setCallEnded(true);

        connectionRef.current.destroy();

        //reloads the page and a new socket.id is generated and handover to the client in the useEffect() (which will be re-runned). This is done due to some issues when we want to start immediatly a new call with same socket
        window.location.reload();
    }

    return (
        <CallContext.Provider value={{call,callAccepted,callEnded,myVideo,userVideo,stream,name,setName,me,callUser,endCall,answerCall,deleteAppointment, getAppointment}}>
            {children}
        </CallContext.Provider>
    )

}

//Custom hook
export const useCall = () => {
    return useContext(CallContext);
}

